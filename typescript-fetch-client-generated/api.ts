/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Brewery Project
 * Specification for OpenAPI Course
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/Franklin098/openapicourse/1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    line1?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 2 letter state code
     * @type {string}
     * @memberof Address
     */
    state?: Address.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipCode?: string;
}

/**
 * @export
 * @namespace Address
 */
export namespace Address {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        AL = <any> 'AL',
        AK = <any> 'AK',
        AZ = <any> 'AZ',
        AR = <any> 'AR',
        CA = <any> 'CA'
    }
}
/**
 * beer object
 * @export
 * @interface Beer
 */
export interface Beer {
    /**
     * 
     * @type {string}
     * @memberof Beer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Beer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Beer
     */
    style?: Beer.StyleEnum;
    /**
     * 
     * @type {number}
     * @memberof Beer
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Beer
     */
    quantity?: number;
    /**
     * 
     * @type {Bewery}
     * @memberof Beer
     */
    bewery?: Bewery;
}

/**
 * @export
 * @namespace Beer
 */
export namespace Beer {
    /**
     * @export
     * @enum {string}
     */
    export enum StyleEnum {
        ALE = <any> 'ALE',
        PALEALE = <any> 'PALE_ALE',
        IPA = <any> 'IPA',
        WHEAT = <any> 'WHEAT',
        LARGER = <any> 'LARGER'
    }
}
/**
 * 
 * @export
 */
export type BeerList = Array<Beer>
/**
 * 
 * @export
 * @interface BeerOrder
 */
export interface BeerOrder {
    /**
     * 
     * @type {string}
     * @memberof BeerOrder
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BeerOrder
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof BeerOrder
     */
    customerRef?: string;
    /**
     * 
     * @type {Array<BeerOrderLine>}
     * @memberof BeerOrder
     */
    beerOrderLines?: Array<BeerOrderLine>;
    /**
     * 
     * @type {string}
     * @memberof BeerOrder
     */
    orderStatusCallbackUrl?: string;
}
/**
 * 
 * @export
 * @interface BeerOrderLine
 */
export interface BeerOrderLine {
    /**
     * 
     * @type {string}
     * @memberof BeerOrderLine
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BeerOrderLine
     */
    beerid?: string;
    /**
     * 
     * @type {string}
     * @memberof BeerOrderLine
     */
    upc: string;
}
/**
 * 
 * @export
 * @interface BeerPagedList
 */
export interface BeerPagedList extends PagedResponse {
    /**
     * 
     * @type {BeerList}
     * @memberof BeerPagedList
     */
    content?: BeerList;
}
/**
 * 
 * @export
 * @interface Bewery
 */
export interface Bewery {
    /**
     * 
     * @type {string}
     * @memberof Bewery
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Bewery
     */
    location?: string;
}
/**
 * customer object
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    lastName?: string;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    address?: Address;
}
/**
 * 
 * @export
 */
export type CustomerList = Array<Customer>
/**
 * 
 * @export
 * @interface CustomerPagedList
 */
export interface CustomerPagedList extends PagedResponse {
    /**
     * 
     * @type {CustomerList}
     * @memberof CustomerPagedList
     */
    content?: CustomerList;
}
/**
 * 
 * @export
 * @interface PagedResponse
 */
export interface PagedResponse {
    /**
     * 
     * @type {PagedResponsePageable}
     * @memberof PagedResponse
     */
    pageable?: PagedResponsePageable;
    /**
     * 
     * @type {number}
     * @memberof PagedResponse
     */
    totalPages?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PagedResponse
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PagedResponse
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedResponse
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedResponse
     */
    number?: number;
}
/**
 * 
 * @export
 * @interface PagedResponsePageable
 */
export interface PagedResponsePageable {
    /**
     * 
     * @type {PagedResponsePageableSort}
     * @memberof PagedResponsePageable
     */
    sort?: PagedResponsePageableSort;
    /**
     * 
     * @type {number}
     * @memberof PagedResponsePageable
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedResponsePageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedResponsePageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PagedResponsePageable
     */
    paged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PagedResponsePageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface PagedResponsePageableSort
 */
export interface PagedResponsePageableSort {
    /**
     * 
     * @type {boolean}
     * @memberof PagedResponsePageableSort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PagedResponsePageableSort
     */
    unsorted?: boolean;
}
/**
 * BeersApi - fetch parameter creator
 * @export
 */
export const BeersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a single **Beer** by its Id value.
         * @summary Delete Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBeerByIdV1(beerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'beerId' is not null or undefined
            if (beerId === null || beerId === undefined) {
                throw new RequiredError('beerId','Required parameter beerId was null or undefined when calling deleteBeerByIdV1.');
            }
            const localVarPath = `/v1/beers/{beerId}`
                .replace(`{${"beerId"}}`, encodeURIComponent(String(beerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single **beer** by its Id value.
         * @summary Get Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeerByIdV1(beerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'beerId' is not null or undefined
            if (beerId === null || beerId === undefined) {
                throw new RequiredError('beerId','Required parameter beerId was null or undefined when calling getBeerByIdV1.');
            }
            const localVarPath = `/v1/beers/{beerId}`
                .replace(`{${"beerId"}}`, encodeURIComponent(String(beerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of beers in the system
         * @summary List Beers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBeersV1(pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/beers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update fields of a beer by its Id value
         * @summary Update a Beer by Id
         * @param {string} beerId Beer Id
         * @param {Beer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBeerByIdV1(beerId: string, body?: Beer, options: any = {}): FetchArgs {
            // verify required parameter 'beerId' is not null or undefined
            if (beerId === null || beerId === undefined) {
                throw new RequiredError('beerId','Required parameter beerId was null or undefined when calling updateBeerByIdV1.');
            }
            const localVarPath = `/v1/beers/{beerId}`
                .replace(`{${"beerId"}}`, encodeURIComponent(String(beerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Beer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Beer
         * @summary New Beer
         * @param {Beer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BeersPost(body: Beer, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1BeersPost.');
            }
            const localVarPath = `/v1/beers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Beer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BeersApi - functional programming interface
 * @export
 */
export const BeersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a single **Beer** by its Id value.
         * @summary Delete Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBeerByIdV1(beerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeersApiFetchParamCreator(configuration).deleteBeerByIdV1(beerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a single **beer** by its Id value.
         * @summary Get Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeerByIdV1(beerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Beer> {
            const localVarFetchArgs = BeersApiFetchParamCreator(configuration).getBeerByIdV1(beerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of beers in the system
         * @summary List Beers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBeersV1(pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BeerPagedList> {
            const localVarFetchArgs = BeersApiFetchParamCreator(configuration).listBeersV1(pageNumber, pageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update fields of a beer by its Id value
         * @summary Update a Beer by Id
         * @param {string} beerId Beer Id
         * @param {Beer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBeerByIdV1(beerId: string, body?: Beer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeersApiFetchParamCreator(configuration).updateBeerByIdV1(beerId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Beer
         * @summary New Beer
         * @param {Beer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BeersPost(body: Beer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BeersApiFetchParamCreator(configuration).v1BeersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BeersApi - factory interface
 * @export
 */
export const BeersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a single **Beer** by its Id value.
         * @summary Delete Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBeerByIdV1(beerId: string, options?: any) {
            return BeersApiFp(configuration).deleteBeerByIdV1(beerId, options)(fetch, basePath);
        },
        /**
         * Get a single **beer** by its Id value.
         * @summary Get Beer by Id
         * @param {string} beerId Beer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeerByIdV1(beerId: string, options?: any) {
            return BeersApiFp(configuration).getBeerByIdV1(beerId, options)(fetch, basePath);
        },
        /**
         * Get a list of beers in the system
         * @summary List Beers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBeersV1(pageNumber?: number, pageSize?: number, options?: any) {
            return BeersApiFp(configuration).listBeersV1(pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * Update fields of a beer by its Id value
         * @summary Update a Beer by Id
         * @param {string} beerId Beer Id
         * @param {Beer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBeerByIdV1(beerId: string, body?: Beer, options?: any) {
            return BeersApiFp(configuration).updateBeerByIdV1(beerId, body, options)(fetch, basePath);
        },
        /**
         * Create a new Beer
         * @summary New Beer
         * @param {Beer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BeersPost(body: Beer, options?: any) {
            return BeersApiFp(configuration).v1BeersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * BeersApi - object-oriented interface
 * @export
 * @class BeersApi
 * @extends {BaseAPI}
 */
export class BeersApi extends BaseAPI {
    /**
     * Delete a single **Beer** by its Id value.
     * @summary Delete Beer by Id
     * @param {string} beerId Beer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeersApi
     */
    public deleteBeerByIdV1(beerId: string, options?: any) {
        return BeersApiFp(this.configuration).deleteBeerByIdV1(beerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a single **beer** by its Id value.
     * @summary Get Beer by Id
     * @param {string} beerId Beer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeersApi
     */
    public getBeerByIdV1(beerId: string, options?: any) {
        return BeersApiFp(this.configuration).getBeerByIdV1(beerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of beers in the system
     * @summary List Beers
     * @param {number} [pageNumber] Page Number
     * @param {number} [pageSize] Page Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeersApi
     */
    public listBeersV1(pageNumber?: number, pageSize?: number, options?: any) {
        return BeersApiFp(this.configuration).listBeersV1(pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * Update fields of a beer by its Id value
     * @summary Update a Beer by Id
     * @param {string} beerId Beer Id
     * @param {Beer} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeersApi
     */
    public updateBeerByIdV1(beerId: string, body?: Beer, options?: any) {
        return BeersApiFp(this.configuration).updateBeerByIdV1(beerId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Beer
     * @summary New Beer
     * @param {Beer} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BeersApi
     */
    public v1BeersPost(body: Beer, options?: any) {
        return BeersApiFp(this.configuration).v1BeersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CustomersApi - fetch parameter creator
 * @export
 */
export const CustomersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a single **Customer** by its Id value.
         * @summary Delete Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerByIdV1(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling deleteCustomerByIdV1.');
            }
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single **Customer** by its Id value.
         * @summary Get Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdV1(customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomerByIdV1.');
            }
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of customers in the system
         * @summary List Customers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomersV1(pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer by its Id value
         * @summary Update Customer
         * @param {Customer} body 
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerByIdV1(body: Customer, customerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCustomerByIdV1.');
            }
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling updateCustomerByIdV1.');
            }
            const localVarPath = `/v1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer
         * @summary New Customer
         * @param {Customer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersPost(body: Customer, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v1CustomersPost.');
            }
            const localVarPath = `/v1/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a single **Customer** by its Id value.
         * @summary Delete Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerByIdV1(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).deleteCustomerByIdV1(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a single **Customer** by its Id value.
         * @summary Get Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdV1(customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).getCustomerByIdV1(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of customers in the system
         * @summary List Customers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomersV1(pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerPagedList> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).listCustomersV1(pageNumber, pageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a customer by its Id value
         * @summary Update Customer
         * @param {Customer} body 
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerByIdV1(body: Customer, customerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).updateCustomerByIdV1(body, customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new customer
         * @summary New Customer
         * @param {Customer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersPost(body: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomersApiFetchParamCreator(configuration).v1CustomersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a single **Customer** by its Id value.
         * @summary Delete Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerByIdV1(customerId: string, options?: any) {
            return CustomersApiFp(configuration).deleteCustomerByIdV1(customerId, options)(fetch, basePath);
        },
        /**
         * Get a single **Customer** by its Id value.
         * @summary Get Customer by Id
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByIdV1(customerId: string, options?: any) {
            return CustomersApiFp(configuration).getCustomerByIdV1(customerId, options)(fetch, basePath);
        },
        /**
         * Get a list of customers in the system
         * @summary List Customers
         * @param {number} [pageNumber] Page Number
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomersV1(pageNumber?: number, pageSize?: number, options?: any) {
            return CustomersApiFp(configuration).listCustomersV1(pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * Update a customer by its Id value
         * @summary Update Customer
         * @param {Customer} body 
         * @param {string} customerId Customer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerByIdV1(body: Customer, customerId: string, options?: any) {
            return CustomersApiFp(configuration).updateCustomerByIdV1(body, customerId, options)(fetch, basePath);
        },
        /**
         * Create a new customer
         * @summary New Customer
         * @param {Customer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersPost(body: Customer, options?: any) {
            return CustomersApiFp(configuration).v1CustomersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Delete a single **Customer** by its Id value.
     * @summary Delete Customer by Id
     * @param {string} customerId Customer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomerByIdV1(customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).deleteCustomerByIdV1(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a single **Customer** by its Id value.
     * @summary Get Customer by Id
     * @param {string} customerId Customer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomerByIdV1(customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).getCustomerByIdV1(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of customers in the system
     * @summary List Customers
     * @param {number} [pageNumber] Page Number
     * @param {number} [pageSize] Page Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public listCustomersV1(pageNumber?: number, pageSize?: number, options?: any) {
        return CustomersApiFp(this.configuration).listCustomersV1(pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * Update a customer by its Id value
     * @summary Update Customer
     * @param {Customer} body 
     * @param {string} customerId Customer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomerByIdV1(body: Customer, customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).updateCustomerByIdV1(body, customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new customer
     * @summary New Customer
     * @param {Customer} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public v1CustomersPost(body: Customer, options?: any) {
        return CustomersApiFp(this.configuration).v1CustomersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * OrderServiceApi - fetch parameter creator
 * @export
 */
export const OrderServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Place Order
         * @param {string} customerId Customer Id
         * @param {BeerOrder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersCustomerIdOrdersPost(customerId: string, body?: BeerOrder, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling v1CustomersCustomerIdOrdersPost.');
            }
            const localVarPath = `/v1/customers/{customerId}/orders`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication JwtAuthToken required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BeerOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderServiceApi - functional programming interface
 * @export
 */
export const OrderServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Place Order
         * @param {string} customerId Customer Id
         * @param {BeerOrder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersCustomerIdOrdersPost(customerId: string, body?: BeerOrder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderServiceApiFetchParamCreator(configuration).v1CustomersCustomerIdOrdersPost(customerId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderServiceApi - factory interface
 * @export
 */
export const OrderServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Place Order
         * @param {string} customerId Customer Id
         * @param {BeerOrder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersCustomerIdOrdersPost(customerId: string, body?: BeerOrder, options?: any) {
            return OrderServiceApiFp(configuration).v1CustomersCustomerIdOrdersPost(customerId, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrderServiceApi - object-oriented interface
 * @export
 * @class OrderServiceApi
 * @extends {BaseAPI}
 */
export class OrderServiceApi extends BaseAPI {
    /**
     * Place Order
     * @param {string} customerId Customer Id
     * @param {BeerOrder} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public v1CustomersCustomerIdOrdersPost(customerId: string, body?: BeerOrder, options?: any) {
        return OrderServiceApiFp(this.configuration).v1CustomersCustomerIdOrdersPost(customerId, body, options)(this.fetch, this.basePath);
    }

}
